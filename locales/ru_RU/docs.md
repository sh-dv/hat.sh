# [Вступление](#вступление)

---

Hat.sh это свободное [opensource] веб-приложение, которое  обеспечивает безопасное шифрование файлов в браузере.

<br>

# [Возможности](#возможности)

---

### Криптография

- [XChaCha20-Poly1305] - для симметричного шифрования .
- [Argon2id] - для получения ключа на основе пароля.
- [X25519] - для обмена ключами.

Библиотека libsodium используется для всех криптографических алгоритмов. [Технические подробности здесь](#технические-детали).

<br>

### Конфиденциальность

- Приложение работает локально в вашем браузере.
- Никакие данные никогда не собираются и никому не отправляются.​

<br>

### Функциональность

- Безопасное шифрование/дешифрование файлов с помощью паролей или ключей.
- Безопасная генерация случайных паролей.
- Генерация пары асимметричных ключей.
- Аутентифицированный обмен ключами.
- Оценка надежности пароля.

<br>

# [Установка](#установка)

---
Самостоятельно разместить и развернуть hat.sh легко: Вы можете сделать это либо с помощью npm, либо с помощью docker.

Если вы хотите разместить приложение у себя, следуйте этим инструкциям:

<br>

## С помощью npm

Перед установкой убедитесь, что вы используете [nodejs](https://nodejs.org/en/) в котором установлен [npm](https://www.npmjs.com/)

<br >

1. клонируйте репозиторий на гитхабе

```bash
git clone https://github.com/sh-dv/hat.sh.git hat.sh
```

2. перейдите в папку

```bash
cd hat.sh
```

3. установите зависимости

```bash
npm install
```

4. скомпилируйте приложение

```bash
npm run build
```

5. запустите hat.sh

```bash
npm run start
```

приложение должно запуститься и использовать порт 3391.
<br>

если вы хотите запустить приложение в среде разработки, запустите:

<br>

```bash
npm run dev
```

<br>

## С помощью docker

Вы можете установить приложение с помощью docker несколькими способами. Вы вольны выбирать, какой метод вам нравится.

<br>

- #### установка из docker hub 

1. загрузите образ из docker hub

```bash
docker pull shdv/hat.sh:latest
```

2. запустите контейнер

```bash
docker run -d -p 3991:80 shdv/hat.sh
```

<br>

- #### Собрать образ из исходников

1. клонируйте репозиторий на гитхабе

```bash
git clone https://github.com/sh-dv/hat.sh.git hat.sh
```

2. перейдите в папку

```bash
cd hat.sh
```

3. соберите образ с помощью docker

```bash
docker build . -t shdv/hat.sh
```

4. запустите контейнер

```bash
docker run -d -p 3991:80 shdv/hat.sh
```

<br>

- #### С помощью docker compose

1. клонируйте репозиторий на гитхабе

```bash
git clone https://github.com/sh-dv/hat.sh.git hat.sh
```

2. перейдите в папку

```bash
cd hat.sh
```

3. соберите образ с помощью docker compose

```bash
docker compose build
```

4. запустите контейнер

```bash
docker compose up
```

<br>

приложение должно запуститься и использовать порт 3391.

hat.sh также доступно в виде образа Docker. Вы можете найти его на [Docker Hub].

<br>


# [Использование](#использование)

---

## Зашифровка файлов

- ### используя пароль

1. Откройте hat.sh
2. Перейдите на панель Зашифровка.
3. Перетащите или Выберите файлы для зашифровки.
4. Введите или сгенерируйте пароль.
5. Скачайте зашифрованный файл.

> Всегда используйте надежный пароль!

- ### используя публичный и приватный ключи

1. Откройте hat.sh
2. Перейдите на панель Зашифровка.
3. Перетащите или Выберите файлы для зашифровки.
4. Выберите метод для публичного ключа.
5. Введите или загрузите публичный ключ получателя и Ваш приватный ключ.
   если у Вас нет открытого и закрытого ключей - Вы можете сгенерировать их пару.
6. Скачайте зашифрованный файл.
7. Поделитесь своим публичным ключом с получателем, чтобы он смог расшифровать файл.

> Никогда никому не показывайте Ваш приватный ключ! Обмениваться можно только публичными ключами

<br>

## Расшифровка файлов

- ### используя пароль

1. Откройте hat.sh
2. Перейдите на панель Расшифровка.
3. Перетащите или Выберите файлы для расшифровки.
4. Введите пароль.
5. Скачайте расшифрованный файл.

- ### используя публичный и приватный ключи

1. Откройте hat.sh
2. Перейдите на панель Расшифровка.
3. Перетащите или Выберите файлы для расшифровки.
4. Введите или загрузите публичный ключ отправителя и Ваш приватный ключ.
5. Скачайте расшифрованный файл.

<br>

# [Ограничения](#ограничения)

---

### Сигнатура файла

Файлы, зашифрованные с помощью hat.sh, можно идентифицировать, изучив сигнатуру файла, которая используется приложением для проверки содержимого файла. Такие сигнатуры также известны как магические числа или Магические Байты. Эти байты аутентифицированы и не могут быть изменены.

### Браузер Safari и Мобильные браузеры

Браузер Safari и Мобильные браузеры имеют ограничения в один файл с максимальным размером 1 ГБ - из-за некоторых проблем, связанных с service-workers. Кроме того, это ограничение также применяется, когда приложению не удается зарегистрировать service-worker (например, Приватный Просмотр FireFox).

<br>

# [Рекомендации](#рекомендации)

---

### Выбор Пароля

Большинство людей с трудом придумывают и запоминают пароли, что приводит к использованию слабых паролей и повторному использованию паролей. В результате такой неправильной практики шифрование на основе паролей становится значительно менее надёжно. Вот почему рекомендуется использовать встроенный генератор паролей и использовать менеджер паролей, такой как [Bitwarden], где вы можете хранить пароль безопасно.


Если вы хотите выбрать пароль, который сможете запомнить, то вам следует ввести пароль-фразу из 8 и более слов.

<br>

### Использование шифрования с публичным ключом вместо пароля

Если вы шифруете файл, которым собираетесь поделиться с кем-то другим, Вам, вероятно, следует зашифровать его с помощью открытого ключа получателя и Вашего закрытого ключа.

<br>

### Обмен Зашифрованными Файлами

Если вы планируете отправить кому-либо зашифрованный файл, рекомендуется использовать ваш приватный ключ и его публичный ключ для шифрования файла.

Файл можно передать через любое безопасное приложение для обмена файлами.

<br>

### Обмен публичными ключами

Публичные ключи можно передавать другим, их можно отправить в виде файла `.public` или простым текстом.

> Никогда никому не показывайте Ваш приватный ключ! Обмениваться можно только публичными ключами.

<br>

### Хранение Публичного и Приватного ключей

Храните ключи шифрования в надежном месте и сделайте резервную копию на внешнее хранилище.

Не рекомендуется хранить приватный ключ в облачном хранилище!

<br>

### Передача Пароля

Поделиться паролем для расшифровки можно с помощью безопасного приложения для обмена сообщениями со сквозным шифрованием. Рекомендуется использовать функцию _Исчезающие Сообщения_ и удалять пароль после того, как получатель расшифрует файл.

> Никогда не используйте один и тот же пароль для разных файлов.

<br>

# [ЧАВО](#чаво)

---

### Регистрирует или хранит ли приложение какие-либо мои данные?

Нет, hat.sh никогда не хранит ваши данные. Оно работает только локально в вашем браузере.

<hr style="height: 1px">

### Бесплатен ли hat.sh?

Да, Hat.sh бесплатен и всегда будет таким. Впрочем, пожалуйста, задумайтесь о том, чтобы внести [небольшой взнос](https://github.com/sh-dv/hat.sh#donations) для поддержки проекта.

<hr style="height: 1px">

### Какие типы файлов поддерживаются? Есть ли ограничение на размер файла?

Hat.sh принимает все типы файлов. Размер файла не ограничен, что означает, что файлы любого размера могут быть зашифрованы.

Браузер Safari и Мобильные браузеры имеют ограничения в один файл с максимальным размером 1 ГБ.

<hr style="height: 1px">

### Я забыл свой пароль, могу ли я как-то расшифровать свои файлы?

Нет, мы не знаем Вашего пароля. Всегда храните свои пароли в менеджере паролей.

<hr style="height: 1px">

### Почему я вижу уведомление "Действуют ограничения (один файл, 1 ГБ)"?

Это означает, что ваш браузер не поддерживает API-интерфейс server-worker fetch. Следовательно, Вы ограничены файлами небольшого размера. См. [Ограничения](#ограничения) для получения дополнительной информации.

<hr style="height: 1px" id="why-need-private-key">

### Безопасно ли делиться своим публичным ключом?

Да. Публичные ключи можно передавать другим, их можно отправить в виде файла `.public` или простым текстом.

Но никому никогда не давайте Ваш приватный ключ!

<hr style="height: 1px">

### Почему приложение запрашивает мой приватный ключ в режиме шифрования с публичным ключом?

Hat.sh использует аутентифицированное шифрование. Отправитель должен предоставить свой приватный ключ, из обоих ключей будет вычислен новый общий ключ для шифрования файла. Получатель также должен предоставить свой приватный ключ при расшифровке. Tак можно гарантировать, что зашифрованный файл не был подделан и был отправлен настоящим отправителем.

<hr style="height: 1px">

### Я потерял мой приватный ключ, можно ли его восстановить?

Неа. Потерянные закрытые ключи не могут быть восстановлены.

Кроме того, если Вы считаете, что Ваш приватный ключ был скомпрометирован (например, приватный ключ был случайно переслан/показан кому-то или Ваш компьютер был взломан), то Вы должны расшифровать все файлы, которые были зашифрованы с помощью этого ключа, сгенерировать новую пару ключей и повторно зашифровать файлы.

<hr style="height: 1px">

### Как сгенерировать пару ключей (Публичный и Приватный)?

Вы можете сгенерировать ключи, посетив [страницу создания ключей](https://hat.sh/generate-keys), не забудьте [хранить ключи безопасно](#рекомендации).

<hr style="height: 1px">

### Измеряет ли приложение надежность пароля?

Мы используем JS реализацию [zxcvbn](https://github.com/dropbox/zxcvbn) для проверки энтропии вводимого пароля, эта энтропия будет преобразована в оценку, которая будет отображаться на экране.

<hr style="height: 1px">

### Подключается ли приложение к Интернету?

Как только вы заходите на сайт и страница загружается, она работает полностью офлайн.

<hr style="height: 1px">

### Как я могу внести свой вклад?

Hat.sh это приложение с открытым исходным кодом. Вы можете помочь сделать его лучше, сделав коммиты на GitHub. Проект поддерживается в мое свободное время. [Пожертвования](https://github.com/sh-dv/hat.sh#donations) любого размера приветствуются.

<hr style="height: 1px">

### Как сообщить об ошибках? 

Пожалуйста, сообщайте об ошибках через [Github], открывая проблему с пометкой "bug".

<hr style="height: 1px">

### Как сообщить об уязвимости в системе безопасности?

Если вы обнаружите действительную проблему безопасности, напишите письмо по адресу hatsh-security@pm.me.

На данный момент наград за находки нет, но ваша учетная запись github будет указана в разделе благодарностей в документации приложения.

<hr style="height: 1px">

### Почему я должен использовать hat.sh? 

1. Приложение использует быстрые современные безопасные криптографические алгоритмы.
2. Оно очень быстрое и простое в использовании.
3. Работает в браузере, ничего настраивать и устанавливать не нужно.
4. Это бесплатное программное обеспечение с открытым исходным кодом, которое можно легко разместить самостоятельно.

<hr style="height: 1px">

### Когда мне не следует использовать hat.sh?

1. Если вы хотите зашифровать диск (лучше используйте, к примеру, [VeraCrypt]).
2. Если вы хотите часто получать доступ к зашифрованным файлам (лучше используйте, к примеру, [Cryptomator]).
3. Если вы хотите шифровать и подписывать файлы в одном инструменте. (лучше используйте, к примеру, [Kryptor]).
4. Если вы предпочитаете инструмент командной строки (лучше используйте, к примеру, [Kryptor]).
5. Если вам нужно что-то, что соответствует отраслевым стандартам, используйте [GPG].

<br>

# [Технические детали](#технические-детали)

---

### Хэширование паролей и Генерация ключей

Функции хеширования паролей получают секретный ключ любого размера из пароля и соли.

<br>

<div class="codeBox">

```javascript
let salt = sodium.randombytes_buf(sodium.crypto_pwhash_SALTBYTES);
let key = sodium.crypto_pwhash(
  sodium.crypto_secretstream_xchacha20poly1305_KEYBYTES,
  password,
  salt,
  sodium.crypto_pwhash_OPSLIMIT_INTERACTIVE,
  sodium.crypto_pwhash_MEMLIMIT_INTERACTIVE,
  sodium.crypto_pwhash_ALG_ARGON2ID13
);
```

</div>

Функция `crypto_pwhash()` извлекает ключ длиной 256 бит из пароля и соли, фиксированная длина которой составляет 128 бит, что должно быть непредсказуемым.

`randombytes_buf()` — это самый простой способ заполнить 128 бит соли.

<br>

`OPSLIMIT` определяет максимальный лимит операций вычисления.

`MEMLIMIT` это максимальный объем ОЗУ, который будет использовать функция, в байтах.

<br>

`crypto_pwhash_OPSLIMIT_INTERACTIVE` и `crypto_pwhash_MEMLIMIT_INTERACTIVE` определяют значения по умолчанию для этих двух параметров. В настоящее время для этого требуется 64 МБ выделенной оперативной памяти. Что подходит для операций в браузере.
<br>
`crypto_pwhash_ALG_ARGON2ID13` использует алгоритм Argon2id версии 1.3.

<br>

### Зашифровка файлов (потоковая)

Чтобы использовать приложение для шифрования файла, пользователь должен предоставить валидный файл и пароль. Этот пароль хешируется, и хеш используется Argon2id чтобы вычислить безопасный ключ для шифрования файла.

<br>

<div class="codeBox">

```javascript
let res = sodium.crypto_secretstream_xchacha20poly1305_init_push(key);
header = res.header;
state = res.state;

let tag = last
  ? sodium.crypto_secretstream_xchacha20poly1305_TAG_FINAL
  : sodium.crypto_secretstream_xchacha20poly1305_TAG_MESSAGE;

let encryptedChunk = sodium.crypto_secretstream_xchacha20poly1305_push(
  state,
  new Uint8Array(chunk),
  null,
  tag
);

stream.enqueue(signature, salt, header, encryptedChunk);
```

</div>

Функция `crypto_secretstream_xchacha20poly1305_init_push` создает зашифрованный поток, в котором инициализируется состояние `state` с помощью ключа и внутреннего, автоматически сгенерированного вектора инициализации. Затем он сохраняет заголовок потока в `header` размером 192 бита.

Это первая функция, вызываемая для создания зашифрованного потока. Ключ больше не потребуется для последующих операций.

<br>

Зашифрованный поток начинается с короткого заголовка, размер которого составляет 192 бита. Этот заголовок должен быть отправлен/сохранен перед последовательностью зашифрованных сообщений, так как он необходим для расшифровки потока. Содержимое заголовка не обязательно должно быть секретным, потому что расшифровка с другим заголовком завершится неудачей.

Тег прикрепляется к каждому сообщению в соответствии со значением `last`, которое указывает, является ли это последним фрагментом файла или нет. Этот тег может быть любым из:

1. `crypto_secretstream_xchacha20poly1305_TAG_MESSAGE`: Это не добавляет никакой информации о характере сообщения.
2. `crypto_secretstream_xchacha20poly1305_TAG_FINAL`: Это указывает на то, что сообщение отмечает конец потока и стирает секретный ключ, используемый для шифрования предыдущей последовательности.

Функция `crypto_secretstream_xchacha20poly1305_push()` шифрует фрагмент `chunk` файла, используя `state` и `tag`, без какой-либо дополнительной информации (`null`).
<br>

для шифрования используется потоковый шифр XChaCha20 с аутентификацией Poly1305 MAC.

функция `stream.enqueue()` добавляет подпись hat.sh (магические байты), соль и заголовок, за которыми следуют зашифрованные фрагменты.

### Расшифровка файлов (потоковая)

<div class="codeBox">

```javascript
let state = sodium.crypto_secretstream_xchacha20poly1305_init_pull(header, key);

let result = sodium.crypto_secretstream_xchacha20poly1305_pull(
  state,
  new Uint8Array(chunk)
);

if (result) {
  let decryptedChunk = result.message;
  stream.enqueue(decryptedChunk);

  if (!last) {
    // continue decryption
  }
}
```

</div>

Функция `crypto_secretstream_xchacha20poly1305_init_pull()` инициализирует состояние `state` с помощью секретного `key` и `header`. Ключ вычисляется из пароля, предоставленного во время расшифровки, и заголовка, нарезанного из файла. Ключ больше не потребуется для последующих операций.

<br>

Функция `crypto_secretstream_xchacha20poly1305_pull()` проверяет, что фрагмент `chunk` содержит валидный зашифрованный текст и тег аутентификации для данного состояния `state`.

Эта функция будет оставаться в цикле, пока не будет найдено сообщение с тегом `crypto_secretstream_xchacha20poly1305_TAG_FINAL`.

Если ключ расшифровки неверный, функция возвращает ошибку.

Если зашифрованный текст или тег аутентификации кажутся недействительными, возвращается ошибка.

<br>

### Генерация случайных паролей

<div class="codeBox">

```javascript
let password = sodium.to_base64(
  sodium.randombytes_buf(16),
  sodium.base64_variants.URLSAFE_NO_PADDING
);
return password;
```

</div>

Функция randombytes_buf() заполняет 128 битов, начиная с buf, непредсказуемой последовательностью байтов.

Функция to_base64() кодирует buf как строку Base64 без заполнения.

<br>

### Генерация и обмен ключами

<div class="codeBox">

```javascript
const keyPair = sodium.crypto_kx_keypair();
let keys = {
  publicKey: sodium.to_base64(keyPair.publicKey),
  privateKey: sodium.to_base64(keyPair.privateKey),
};
return keys;
```
</div>

Функция `crypto_kx_keypair()` случайным образом генерирует секретный ключ и соответствующий открытый ключ. Открытый ключ помещается в публичный ключ publicKey, а секретный ключ — в приватный ключ privateKey. Оба по 256 бит.

<br>

<div class="codeBox">

```javascript
let key = sodium.crypto_kx_client_session_keys(
  sodium.crypto_scalarmult_base(privateKey),
  privateKey,
  publicKey
);
```
</div>

Используя API обмена ключей, две стороны могут безопасно вычислить набор общих ключей, используя публичный ключ своего партнера и свой собственный секретный (приватный) ключ.

Функция `crypto_kx_client_session_keys()` вычисляет пару общих ключей длиной 256 бит, используя публичный ключ получателя и приватный ключ отправителя.

Функция `crypto_scalarmult_base()` используется для вычисления публичного ключа отправителя из его приватного ключа.

<br>

### XChaCha20-Poly1305

XChaCha20 - это вариант ChaCha20 с расширенным nonce, позволяющий случайным nonce быть безопасными.

XChaCha20 не требует никаких таблиц поиска и позволяет избежать атак по времени.

Внутри XChaCha20 работает как блочный шифр, используемый в режиме счетчика. Он использует хеш-функцию HChaCha20 для получения subkey и subnonce из исходного ключа и расширенного nonce, а также специальный 64-битный счетчик блоков, чтобы избежать увеличения nonce после каждого блока.

<br>

### отличия V2 от V1

- переход на xchacha20poly1305 для симметричного потокового шифрования и Argon2id для получения ключа на основе пароля. вместо AES-256-GCM и PBKDF2.
- применение библиотеки libsodium для всей криптографии вместо WebCryptoApi.
- в этой версии приложение не читает весь файл в память. вместо этого файл нарезается на фрагменты по 64 МБ, которые обрабатываются один за другим.
- поскольку мы не используем какую-либо обработку на стороне сервера, приложение регистрирует поддельный URL-адрес загрузки (/file), который будет обрабатываться API-интерфейсом service-worker.
- если все проверки пройдены, инициализируется новый поток. затем фрагменты файла передаются из основного приложения в 
  файл service-worker с помощью сообщений.
- каждый фрагмент шифруется/дешифруется отдельно и добавляется в поток.
- после того как каждый фрагмент записывается на диск, он будет удалён сборщиком мусора в браузере, и это приводит к тому, что в памяти никогда не бывает больше нескольких фрагментов одновременно.

<br>

[//]: # "ссылки"
[xchacha20-poly1305]: https://libsodium.gitbook.io/doc/secret-key_cryptography/aead/chacha20-poly1305/xchacha20-poly1305_construction
[argon2id]: https://github.com/p-h-c/phc-winner-argon2
[x25519]: https://cr.yp.to/ecdh.html
[opensource]: https://github.com/sh-dv/hat.sh
[bitwarden]: https://bitwarden.com/
[extending the salsa20 nonce paper]: https://cr.yp.to/snuffle/xsalsa-20081128.pdf
[soon]: https://tools.ietf.org/html/draft-irtf-cfrg-xchacha
[github]: https://github.com/sh-dv/hat.sh
[veracrypt]: https://veracrypt.fr
[cryptomator]: https://cryptomator.org
[kryptor]: https://github.com/samuel-lucas6/Kryptor
[gpg]: https://gnupg.org
[docker hub]: https://hub.docker.com/r/shdv/hat.sh
